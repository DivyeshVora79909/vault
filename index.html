<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Secure Vault Pro v2</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.3/dist/cdn.min.js"
    ></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />

    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              gray: {
                750: "#2d3748",
                850: "#1f2937",
                900: "#111827",
                950: "#0b0f19",
              },
            },
            animation: { "spin-slow": "spin 3s linear infinite" },
          },
        },
      };
    </script>
    <style>
      [x-cloak] {
        display: none !important;
      }

      ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }
      ::-webkit-scrollbar-track {
        background: #0b0f19;
      }
      ::-webkit-scrollbar-thumb {
        background: #374151;
        border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #4b5563;
      }

      iframe {
        border: none;
      }
    </style>
  </head>

  <body
    class="bg-gray-950 text-gray-100 h-screen w-screen overflow-hidden font-sans select-none"
    x-data="vaultApp()"
    @keydown.window="handleGlobalKeydown($event)"
    @dragover.prevent="dragOver = true"
    @dragleave.prevent="dragOver = false"
    @drop.prevent="handleDrop($event)"
  >
    <div
      class="fixed top-4 left-1/2 transform -translate-x-1/2 z-[100]"
      x-cloak
    >
      <div
        x-show="notification.show"
        x-transition.opacity.duration.300ms
        class="bg-gray-800 border border-gray-700 text-white px-4 py-2 rounded-full shadow-2xl flex items-center gap-3 text-sm font-medium"
      >
        <i :class="notification.icon" class="fa-solid"></i>
        <span x-text="notification.message"></span>
      </div>
    </div>

    <div
      x-show="dragOver && view === 'dashboard'"
      x-transition.opacity
      class="fixed inset-0 z-[90] bg-blue-600/20 backdrop-blur-sm border-4 border-blue-500 border-dashed m-4 rounded-xl flex items-center justify-center pointer-events-none"
      x-cloak
    >
      <div class="text-2xl font-bold text-blue-100 drop-shadow-lg">
        <i class="fa-solid fa-cloud-arrow-up mr-2"></i> Drop files to encrypt
      </div>
    </div>

    <section
      x-show="view === 'auth'"
      x-transition:leave="transition ease-in duration-200"
      x-transition:leave-start="opacity-100"
      x-transition:leave-end="opacity-0"
      class="h-full flex flex-col items-center justify-center p-6 relative"
    >
      <div class="text-5xl mb-8 text-gray-700">
        <i class="fa-solid fa-fingerprint"></i>
      </div>

      <div
        class="w-full max-w-sm bg-gray-900 border border-gray-800 p-8 rounded-xl shadow-2xl space-y-5"
      >
        <h1 class="text-xl font-bold text-center text-gray-200 tracking-tight">
          Vault Access
        </h1>

        <div class="flex bg-gray-950 rounded-lg p-1 border border-gray-800">
          <button
            @click="authMode = 'unlock'"
            :class="{'bg-gray-800 text-white shadow': authMode === 'unlock', 'text-gray-500 hover:text-gray-300': authMode !== 'unlock'}"
            class="flex-1 py-1.5 text-xs font-semibold rounded transition-all"
          >
            Open Existing
          </button>
          <button
            @click="authMode = 'create'"
            :class="{'bg-gray-800 text-white shadow': authMode === 'create', 'text-gray-500 hover:text-gray-300': authMode !== 'create'}"
            class="flex-1 py-1.5 text-xs font-semibold rounded transition-all"
          >
            Create New
          </button>
        </div>

        <div x-show="authMode === 'unlock'" class="space-y-4">
          <button
            @click="openFilePicker()"
            class="w-full border-2 border-dashed border-gray-700 hover:border-gray-500 hover:bg-gray-800/50 text-gray-400 py-6 rounded-lg transition-all group flex flex-col items-center justify-center gap-2"
          >
            <i
              class="fa-solid fa-folder-open text-2xl group-hover:scale-110 transition-transform"
            ></i>
            <span
              x-text="fileHandle ? fileHandle.name : 'Select .svault file'"
            ></span>
          </button>

          <input
            type="password"
            x-model="password"
            @keydown.enter="unlockVault()"
            class="w-full bg-gray-950 border border-gray-700 rounded-lg px-4 py-2.5 text-sm focus:ring-1 focus:ring-blue-500 focus:border-blue-500 outline-none transition"
            placeholder="Master Password"
          />

          <button
            @click="unlockVault()"
            :disabled="isLoading"
            class="w-full bg-blue-600 hover:bg-blue-500 disabled:opacity-50 text-white font-medium py-2.5 rounded-lg transition shadow-lg shadow-blue-900/20"
          >
            <span x-show="!isLoading">Unlock</span>
            <span x-show="isLoading"
              ><i class="fa-solid fa-circle-notch fa-spin"></i>
              Processing...</span
            >
          </button>
        </div>

        <div x-show="authMode === 'create'" class="space-y-4" x-cloak>
          <input
            type="password"
            x-model="password"
            class="w-full bg-gray-950 border border-gray-700 rounded-lg px-4 py-2.5 text-sm focus:ring-1 focus:ring-green-500 outline-none transition"
            placeholder="Set Master Password"
          />
          <button
            @click="createVault()"
            class="w-full bg-green-600 hover:bg-green-500 text-white font-medium py-2.5 rounded-lg transition shadow-lg shadow-green-900/20"
          >
            Initialize Vault
          </button>
        </div>
      </div>
    </section>

    <section x-show="view === 'dashboard'" class="h-full flex flex-col" x-cloak>
      <header
        class="bg-gray-900 border-b border-gray-800 h-14 flex justify-between items-center px-4 shrink-0"
      >
        <div class="flex items-center gap-4">
          <div class="flex flex-col">
            <span
              class="text-sm font-bold text-gray-200"
              x-text="fileHandle ? fileHandle.name : 'New Vault'"
            ></span>
            <span
              class="text-[10px] text-gray-500 font-mono"
              x-text="files.length + ' Objects | ' + totalSize"
            ></span>
          </div>
          <span
            x-show="isDirty"
            class="text-[10px] bg-yellow-900/30 text-yellow-500 px-2 py-0.5 rounded border border-yellow-900/50"
            >Unsaved Changes</span
          >
        </div>

        <div class="flex items-center gap-3">
          <div class="relative hidden sm:block">
            <i
              class="fa-solid fa-search absolute left-3 top-1/2 -translate-y-1/2 text-gray-600 text-xs"
            ></i>
            <input
              type="text"
              x-model="searchQuery"
              placeholder="Filter..."
              class="bg-gray-950 border border-gray-800 rounded-full pl-8 pr-3 py-1.5 text-xs w-48 text-gray-300 focus:border-gray-600 outline-none"
            />
          </div>

          <button
            @click="$refs.uploadInput.click()"
            class="bg-gray-800 hover:bg-gray-700 text-gray-300 w-8 h-8 rounded-full flex items-center justify-center transition"
            title="Upload"
          >
            <i class="fa-solid fa-plus"></i>
          </button>

          <button
            @click="saveVault()"
            :class="isDirty ? 'bg-blue-600 hover:bg-blue-500 text-white animate-pulse' : 'bg-gray-800 text-gray-400 hover:text-white'"
            class="px-4 py-1.5 rounded-full text-xs font-bold transition flex items-center gap-2"
          >
            <i class="fa-solid fa-floppy-disk"></i>
            <span x-text="isDirty ? 'Save *' : 'Saved'"></span>
          </button>

          <button
            @click="logout()"
            class="text-gray-500 hover:text-red-400 ml-2"
            title="Close Vault"
          >
            <i class="fa-solid fa-power-off"></i>
          </button>
        </div>
        <input
          type="file"
          multiple
          class="hidden"
          x-ref="uploadInput"
          @change="processUpload($event)"
        />
      </header>

      <main class="flex-1 overflow-y-auto p-4 bg-gray-950" @contextmenu.prevent>
        <div
          x-show="files.length === 0"
          class="h-full flex flex-col items-center justify-center text-gray-600"
        >
          <i class="fa-solid fa-box-open text-4xl mb-2 opacity-30"></i>
          <p class="text-sm">Drag and drop files here</p>
        </div>

        <div
          class="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 xl:grid-cols-10 gap-3 pb-20"
        >
          <template x-for="file in filteredFiles" :key="file.name">
            <div
              class="group relative bg-gray-900 border border-gray-800 hover:border-blue-500/50 hover:bg-gray-800 rounded-lg p-3 cursor-pointer transition flex flex-col items-center"
              @click="openViewer(file)"
              @contextmenu.prevent.stop="showContext($event, file)"
            >
              <div
                class="w-full aspect-square bg-gray-950 rounded flex items-center justify-center mb-2 overflow-hidden relative"
              >
                <i
                  :class="getFileIcon(file.name)"
                  class="text-3xl opacity-80 group-hover:scale-110 transition-transform duration-300"
                ></i>
                <span
                  class="absolute bottom-1 right-1 text-[9px] font-bold bg-gray-800 px-1 rounded text-gray-400 uppercase"
                  x-text="file.ext"
                ></span>
              </div>
              <p
                class="text-xs text-gray-300 truncate w-full text-center"
                x-text="file.name"
              ></p>
            </div>
          </template>
        </div>
      </main>
    </section>

    <div
      x-show="contextMenu.show"
      @click.outside="contextMenu.show = false"
      :style="`top: ${contextMenu.y}px; left: ${contextMenu.x}px`"
      class="fixed z-50 bg-gray-800 border border-gray-700 rounded shadow-xl py-1 min-w-[160px]"
      x-cloak
    >
      <div
        class="px-3 py-1 text-[10px] text-gray-500 uppercase border-b border-gray-700 mb-1 font-mono"
        x-text="contextMenu.file?.name"
      ></div>
      <button
        @click="downloadSingleFile(contextMenu.file); contextMenu.show = false"
        class="w-full text-left px-4 py-2 text-xs hover:bg-gray-700 text-gray-200 flex items-center gap-2"
      >
        <i class="fa-solid fa-download w-4"></i> Export
      </button>

      <button
        x-show="isImage(contextMenu.file?.name)"
        @click="convertImageToPdf(contextMenu.file); contextMenu.show = false"
        class="w-full text-left px-4 py-2 text-xs hover:bg-gray-700 text-gray-200 flex items-center gap-2"
      >
        <i class="fa-solid fa-file-pdf w-4"></i> Convert to PDF
      </button>

      <div class="h-px bg-gray-700 my-1"></div>
      <button
        @click="deleteFile(contextMenu.file?.name); contextMenu.show = false"
        class="w-full text-left px-4 py-2 text-xs hover:bg-gray-700 text-red-400 flex items-center gap-2"
      >
        <i class="fa-solid fa-trash w-4"></i> Delete
      </button>
    </div>

    <div
      x-show="modal.open"
      class="fixed inset-0 z-50 flex flex-col bg-gray-950/95 backdrop-blur-md"
      x-cloak
      x-transition.opacity
    >
      <div
        class="h-12 border-b border-gray-800 flex justify-between items-center px-4 bg-gray-900"
      >
        <div class="flex items-center gap-3">
          <button @click="closeModal()" class="text-gray-400 hover:text-white">
            <i class="fa-solid fa-arrow-left"></i>
          </button>
          <span
            x-text="modal.filename"
            class="text-sm font-mono text-gray-300"
          ></span>
        </div>
        <div class="flex gap-2">
          <button
            x-show="modal.type === 'editor'"
            @click="saveEditorContent()"
            class="bg-blue-600 hover:bg-blue-500 text-white px-3 py-1 rounded text-xs"
          >
            Save Edit
          </button>
        </div>
      </div>

      <div class="flex-1 overflow-hidden flex items-center justify-center p-4">
        <template x-if="modal.type === 'image'">
          <img
            :src="modal.content"
            class="max-w-full max-h-full object-contain shadow-2xl rounded"
          />
        </template>
        <template x-if="modal.type === 'video'">
          <video
            :src="modal.content"
            controls
            class="max-w-full max-h-full shadow-2xl rounded"
          ></video>
        </template>
        <template x-if="modal.type === 'pdf'">
          <iframe
            :src="modal.content"
            class="w-full h-full rounded bg-gray-900"
          ></iframe>
        </template>
        <template x-if="modal.type === 'editor'">
          <textarea
            x-model="modal.textContent"
            class="w-full h-full bg-gray-900 text-gray-300 font-mono text-sm p-4 outline-none resize-none border-none focus:ring-0 max-w-5xl mx-auto"
          ></textarea>
        </template>
        <template x-if="modal.type === 'unknown'">
          <div class="text-center">
            <p class="mb-4 text-gray-500">Preview not available.</p>
            <button
              @click="downloadSingleFile({name: modal.filename})"
              class="text-blue-400 underline"
            >
              Download File
            </button>
          </div>
        </template>
      </div>
    </div>

    <script>
      const Utils = {
        async deriveKey(password, salt) {
          const enc = new TextEncoder();
          const keyMaterial = await crypto.subtle.importKey(
            "raw",
            enc.encode(password),
            { name: "PBKDF2" },
            false,
            ["deriveKey"],
          );
          return crypto.subtle.deriveKey(
            { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
            keyMaterial,
            { name: "AES-GCM", length: 256 },
            false,
            ["encrypt", "decrypt"],
          );
        },
        async encrypt(data, password) {
          const salt = crypto.getRandomValues(new Uint8Array(16));
          const iv = crypto.getRandomValues(new Uint8Array(12));
          const key = await this.deriveKey(password, salt);
          const encrypted = await crypto.subtle.encrypt(
            { name: "AES-GCM", iv },
            key,
            data,
          );
          const buffer = new Uint8Array(
            salt.byteLength + iv.byteLength + encrypted.byteLength,
          );
          buffer.set(salt, 0);
          buffer.set(iv, 16);
          buffer.set(new Uint8Array(encrypted), 28);
          return buffer;
        },
        async decrypt(buffer, password) {
          const salt = buffer.slice(0, 16);
          const iv = buffer.slice(16, 28);
          const data = buffer.slice(28);
          const key = await this.deriveKey(password, salt);
          return await crypto.subtle.decrypt(
            { name: "AES-GCM", iv },
            key,
            data,
          );
        },
        formatSize(bytes) {
          if (bytes === 0) return "0 B";
          const k = 1024;
          const sizes = ["B", "KB", "MB", "GB"];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return (
            parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + " " + sizes[i]
          );
        },
      };

      function vaultApp() {
        return {
          view: "auth",
          authMode: "unlock",
          password: "",
          zip: null,
          files: [],
          fileHandle: null,
          isDirty: false,
          isLoading: false,
          dragOver: false,
          searchQuery: "",

          notification: { show: false, message: "", icon: "" },

          contextMenu: { show: false, x: 0, y: 0, file: null },

          modal: {
            open: false,
            type: null,
            content: null,
            textContent: "",
            filename: "",
          },

          viewers: {
            image: ["jpg", "jpeg", "png", "gif", "webp", "svg", "bmp"],
            video: ["mp4", "webm", "mov"],
            pdf: ["pdf"],
            editor: [
              "txt",
              "md",
              "json",
              "xml",
              "html",
              "css",
              "js",
              "csv",
              "log",
            ],
          },

          init() {
            window.onbeforeunload = (e) => {
              if (this.isDirty) {
                e.preventDefault();
                return (e.returnValue = "Unsaved changes. Exit?");
              }
            };
          },

          get totalSize() {
            const size = this.files.reduce(
              (acc, f) => acc + f._data.uncompressedSize,
              0,
            );
            return Utils.formatSize(size);
          },
          get filteredFiles() {
            if (!this.searchQuery) return this.files;
            return this.files.filter((f) =>
              f.name.toLowerCase().includes(this.searchQuery.toLowerCase()),
            );
          },

          notify(msg, type = "success") {
            this.notification = {
              show: true,
              message: msg,
              icon:
                type === "error"
                  ? "fa-circle-exclamation text-red-500"
                  : "fa-circle-check text-green-500",
            };
            setTimeout(() => (this.notification.show = false), 3000);
          },

          handleGlobalKeydown(e) {
            if ((e.ctrlKey || e.metaKey) && e.key === "s") {
              e.preventDefault();
              if (this.view === "dashboard") this.saveVault();
              if (this.modal.open && this.modal.type === "editor")
                this.saveEditorContent();
            }

            if (e.key === "Escape") {
              if (this.modal.open) this.closeModal();
              this.contextMenu.show = false;
            }
          },

          async openFilePicker() {
            try {
              if (window.showOpenFilePicker) {
                const handles = await window.showOpenFilePicker({
                  types: [
                    {
                      description: "Secure Vault",
                      accept: { "application/octet-stream": [".svault"] },
                    },
                  ],
                  multiple: false,
                });
                this.fileHandle = handles[0];
              } else {
                this.$refs.uploadInput.click();
                this.notify(
                  "Browser doesn't support direct editing. You will need to download on save.",
                  "error",
                );
              }
            } catch (err) {
              console.log(err);
            }
          },

          async createVault() {
            if (!this.password)
              return this.notify("Password required", "error");
            this.zip = new JSZip();
            this.files = [];
            this.fileHandle = null;
            this.view = "dashboard";
            this.isDirty = true;
            this.notify("Vault created locally");
          },

          async unlockVault() {
            let fileData = null;

            try {
              this.isLoading = true;
              if (this.fileHandle) {
                const file = await this.fileHandle.getFile();
                fileData = await file.arrayBuffer();
              } else if (this.$refs.uploadInput.files.length) {
                const file = this.$refs.uploadInput.files[0];
                this.fileHandle = null;
                fileData = await file.arrayBuffer();
              } else {
                throw new Error("No file selected");
              }

              const decrypted = await Utils.decrypt(
                new Uint8Array(fileData),
                this.password,
              );
              this.zip = await JSZip.loadAsync(decrypted);
              this.refreshFiles();
              this.view = "dashboard";
              this.notify("Access Granted");
            } catch (e) {
              console.error(e);
              this.notify("Decryption failed. Wrong password?", "error");
            } finally {
              this.isLoading = false;
            }
          },

          refreshFiles() {
            this.files = Object.values(this.zip.files)
              .filter((f) => !f.dir)
              .map((f) => ({
                ...f,
                ext: f.name.split(".").pop().toLowerCase(),
              }))
              .sort((a, b) => a.name.localeCompare(b.name));
          },

          async processUpload(e) {
            const files = e.target.files || e.dataTransfer.files;
            if (!files.length) return;

            for (let file of files) this.zip.file(file.name, file);

            this.refreshFiles();
            this.isDirty = true;
            this.notify(`${files.length} items added`);
            if (e.target) e.target.value = "";
          },

          handleDrop(e) {
            this.dragOver = false;
            if (this.view === "dashboard") this.processUpload(e);
          },

          async saveVault() {
            if (!this.zip) return;
            try {
              this.isLoading = true;
              this.notify("Encrypting & Saving...", "success");

              const content = await this.zip.generateAsync({
                type: "uint8array",
                compression: "DEFLATE",
              });
              const encrypted = await Utils.encrypt(content, this.password);

              if (this.fileHandle && window.showSaveFilePicker) {
                const writable = await this.fileHandle.createWritable();
                await writable.write(encrypted);
                await writable.close();
                this.notify("Saved to disk");
              } else {
                const blob = new Blob([encrypted], {
                  type: "application/octet-stream",
                });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = `vault_${Date.now()}.svault`;
                link.click();
                this.notify("File downloaded (Save not native)");
              }

              this.isDirty = false;
            } catch (e) {
              this.notify("Save failed: " + e.message, "error");
            } finally {
              this.isLoading = false;
            }
          },

          deleteFile(name) {
            if (confirm(`Remove ${name}?`)) {
              this.zip.remove(name);
              this.refreshFiles();
              this.isDirty = true;
            }
          },

          logout() {
            this.view = "auth";
            this.password = "";
            this.zip = null;
            this.files = [];
            this.fileHandle = null;
          },

          isImage(name) {
            if (!name) return false;
            return this.viewers.image.includes(
              name.split(".").pop().toLowerCase(),
            );
          },

          async convertImageToPdf(fileObj) {
            try {
              this.notify("Converting...", "success");
              const fileData = await this.zip
                .file(fileObj.name)
                .async("base64");
              const ext = fileObj.ext.toUpperCase();

              const { jsPDF } = window.jspdf;
              const doc = new jsPDF();

              const imgProps = doc.getImageProperties(fileData);
              const pdfWidth = doc.internal.pageSize.getWidth();
              const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;

              doc.addImage(
                fileData,
                ext === "JPG" ? "JPEG" : ext,
                0,
                0,
                pdfWidth,
                pdfHeight,
              );

              const pdfBlob = doc.output("blob");
              const newName = fileObj.name.replace(/\.[^/.]+$/, "") + ".pdf";

              this.zip.file(newName, pdfBlob);
              this.refreshFiles();
              this.isDirty = true;
              this.notify("PDF Created");
            } catch (e) {
              console.error(e);
              this.notify("Conversion failed", "error");
            }
          },

          showContext(e, file) {
            this.contextMenu = {
              show: true,
              x: e.clientX,
              y: e.clientY,
              file: file,
            };

            this.$nextTick(() => {
              if (this.contextMenu.y + 150 > window.innerHeight)
                this.contextMenu.y -= 150;
              if (this.contextMenu.x + 160 > window.innerWidth)
                this.contextMenu.x -= 160;
            });
          },

          async openViewer(fileObj) {
            const file = this.zip.file(fileObj.name);
            const ext = fileObj.ext;
            this.modal.filename = fileObj.name;
            this.modal.open = true;

            if (this.viewers.image.includes(ext)) {
              this.modal.type = "image";
              this.modal.content = URL.createObjectURL(
                await file.async("blob"),
              );
            } else if (this.viewers.video.includes(ext)) {
              this.modal.type = "video";
              this.modal.content = URL.createObjectURL(
                await file.async("blob"),
              );
            } else if (this.viewers.pdf.includes(ext)) {
              this.modal.type = "pdf";
              const blob = await file.async("blob");
              this.modal.content = URL.createObjectURL(
                new Blob([blob], { type: "application/pdf" }),
              );
            } else if (this.viewers.editor.includes(ext)) {
              this.modal.type = "editor";
              this.modal.textContent = await file.async("string");
            } else {
              this.modal.type = "unknown";
            }
          },

          saveEditorContent() {
            this.zip.file(this.modal.filename, this.modal.textContent);
            this.isDirty = true;
            this.notify("Text updated in memory");
          },

          async downloadSingleFile(fileObj) {
            const blob = await this.zip.file(fileObj.name).async("blob");
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = fileObj.name;
            link.click();
          },

          closeModal() {
            this.modal.open = false;
            if (this.modal.content) URL.revokeObjectURL(this.modal.content);
            this.modal.content = null;
          },

          getFileIcon(name) {
            const ext = name.split(".").pop().toLowerCase();
            if (this.viewers.image.includes(ext))
              return "fa-regular fa-image text-purple-400";
            if (this.viewers.video.includes(ext))
              return "fa-solid fa-film text-red-400";
            if (this.viewers.pdf.includes(ext))
              return "fa-solid fa-file-pdf text-red-500";
            if (this.viewers.editor.includes(ext))
              return "fa-regular fa-file-code text-blue-400";
            if (["zip", "rar", "7z"].includes(ext))
              return "fa-solid fa-file-zipper text-yellow-400";
            return "fa-regular fa-file text-gray-500";
          },
        };
      }
    </script>
  </body>
</html>
